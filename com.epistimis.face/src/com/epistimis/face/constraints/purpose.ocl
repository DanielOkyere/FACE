import  '../../../../../model/generated/Face.ecore'
/**
 * This contains more general capability for the Purpose EXTENSIONS 
 */

package face 

  context FaceElement
  
   /**
	 * Declare a helper operation to map an ok/warning verdict to ok/error.
	 */
	def: asError(verdict : Boolean) : Boolean = if verdict then true else null endif

  context PurposeEnumerated
    /*
     * Helper method - flattens the hierarchy. Can't just use 'flatten' because it expects a collection only , not objects that include collections
     * as members.
	 *
	 *	NOTE: Should this include 'self' at this level because the enum name is not itself a label? This is different than a PurposeSet, where the 
	 *	name of the set is included. Including it (which we do here) does insure that there is no duplication, which would be confusing
	 * 
	 */
   	 def: flattenLabels(): Collection(PurposeBase) =
   	    self.label->closure(e: PurposeBase | if e.oclIsTypeOf(PurposeSet) then e.oclAsType(PurposeSet).label else Bag{e} endif)
   	    	->including(self.oclAsType(PurposeBase))
   	    	-- While not absolutely required, sorting this makes it easier to identify duplicates
   	    	-- ->sortedBy(e|e.name)
   

	-- If there are duplicates, can use this function to order them - then print out their names
	 def: sortedContents(): Collection(PurposeBase) =
	 	self.label->closure(e: PurposeBase | if e.oclIsTypeOf(PurposeSet) then e.oclAsType(PurposeSet).label else Bag{e} endif)->sortedBy(e|e.name)
	 

     inv enumerationLabelNameUniqueDrillDown('Enumeration labels must be unique within the entire enumeration hierarchy. '+ self.name + ' contains a duplicate. Remove duplicate(s) to continue'):
     	asError(self.flattenLabels()->isUnique(name))
    
  context PurposeBase
     /*
     * Helper method that reroutes based on derived type
     */      
    def: flattenLabels(): Collection(PurposeBase) =
      if self.oclIsTypeOf(PurposeSet) then
        self.oclAsType(PurposeSet).flattenLabels()
      else -- 
        self.oclAsType(PurposeLabel).flattenLabels()
      endif    	
 
      
  context PurposeSet
  /**
   * Helper method that flattens set contents
   */  
   	 def: flattenLabels(): Collection(PurposeBase) =
  	    self.label->closure(e: PurposeBase | if e.oclIsTypeOf(PurposeSet) then e.oclAsType(PurposeSet).label else Bag{e} endif)->including(self.oclAsType(PurposeBase))
 
   	 	
  context PurposeLabel
    /*
     * Helper method - end of recursion 
     */    	 
   	def: flattenLabels(): Bag(PurposeBase) =
   		Bag{self.oclAsType(PurposeBase)}
  
 endpackage